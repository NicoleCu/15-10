# Алгоритм Хэмминга. На ввод программа получает последовательность из 0 и 1,
# выводит последовательность с контрольными битами

import math

a = input()
a = list(a)
k = 2   # минимально возможное количество контрольных разрядов
mn = math.log10(2)
while k * mn < math.log10(k + len(a) + 1):         # вычисляем по формуле минимальное k(пригодится для
                                                            # кусков последовательности != 16)
    k += 1
if len(a) > 16:
    c = [[""] * 21 for i in range(((len(a))//16))]       # строка разбивается по 16 символов + 5 контрольных
else:
    c = [[""] * (len(a)+k)]
for l in range(len(c)):
    if len(c[l]) >= 2:                  # присваиваются позиции контрольным битам с учетом сдвига в нумерации списка
        c[l][0] = '-'
        c[l][1] = '-'
    if len(c[l]) >= 4:
        c[l][3] = '-'
    if len(c[l]) >= 8:
        c[l][7] = '-'
    if len(c[l]) >= 16:
        c[l][15] = '-'
if len(a) % 16 != 0:                    # убирает лишние позиции если не удается разбить строку ровно по 16
    del c[-1][(len(a) % 16) + k:]
for t in range(len(c)):
    for j in range(len(c[t])):
        if c[t][j] == "":
            c[t][j] = a[0]
            del a[0]
for y in range(len(c)):                      # считает значение каждого контрольного бита
        l = c[y][::2].count('1')
        f = c[y][2::4].count('1') + c[y][3::4].count('1')
        if l % 2 == 0:
            c[y][0] = '0'
        else:
            c[y][0] = '1'
        if f % 2 == 0:
            c[y][1] = '0'
        else:
            c[y][1] = '1'
        if len(c[y]) >= 4:
            u = c[y][3:6].count('1') + c[y][11:14].count('1')
            if u % 2 == 0:
                c[y][3] = '0'
            else:
                c[y][3] = '1'                     # при нечетной контрольной сумме биту присваивается 1, при четной - 0
        if len(c[y]) >= 8:
            s = c[y][7:15].count('1')
            if s % 2 == 0:
                c[y][7] = '0'
            else:
                c[y][7] = '1'
        if len(c[y]) >= 16:
            m = c[y][16::].count('1')
            if m % 2 == 0:
                c[y][15] = '0'
            else:
                c[y][15] = '1'
for z in c:
    for elem in z:
        print(elem, end='')
